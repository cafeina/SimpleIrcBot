#include <algorithm>
#include <dirent.h>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <sys/stat.h>

#include "utilities.h"


using std::cout;
using std::endl;
using std::string;
using std::vector;

vector<string> list_files(string directory, string extension)
{
    DIR *dp;
    struct dirent *dirp;

    if(directory[directory.size()-1] != '/') directory += "/";

    dp = opendir(directory.c_str());

    vector<string> files;

    while((dirp = readdir(dp)) != NULL)
    {
        string file_name = dirp->d_name;

        if(file_name == "." || file_name == "..") 
            continue;

        if(file_name.substr(file_name.size()-extension.size()) == extension) 
            files.push_back(directory+file_name);

        if((dirp->d_type == DT_DIR) && (file_name != "..") && (file_name != "."))
        {
            vector<string> r_files = list_files(directory+file_name, extension);
            files.insert(files.end(), r_files.begin(), r_files.end());
        }
    }
    closedir(dp);
    return files;
}

std::vector<std::string> split(const std::string &str, const std::string delim)
{

	std::vector<std::string> words;

    size_t word_begin = 0;
    size_t word_end = 0;
    
    while(true)
    {
        while(str.substr(word_begin, delim.size()) == delim)
            word_begin += delim.size();
        
        word_end = str.find(delim, word_begin+1);

        std::string new_word;
        if(word_end != std::string::npos)
            new_word = str.substr(word_begin, (word_end-word_begin));
        else
            new_word = str.substr(word_begin);

        words.push_back(new_word);

        if(word_end == std::string::npos) break;

        while(str.substr(word_end, delim.size()) == delim)
            word_end += delim.size();

        if((str.substr(word_end) == delim) || (word_end == str.size())) break;

        if(word_end+1 < str.size())
            word_begin = word_end;

    }

	return words;
}

std::string get_file_name(const std::string &path_file_name)
{
	std::string path_separator = "\\/";
	std::string file_name;
	size_t pos_separator = path_file_name.find_last_of(path_separator);
	if (pos_separator == std::string::npos)
		file_name = path_file_name;
	else
		file_name = path_file_name.substr(pos_separator+1);

	return file_name;
}

std::string get_path(const std::string &path_file_name)
{
	std::string path_separator = "\\/";
	std::string path;
	size_t pos_separator = path_file_name.find_last_of(path_separator);
	if (pos_separator == std::string::npos)
		path = path_file_name;
	else
		path = path_file_name.substr(0, pos_separator+1);

	return path;
}

string trim(const string &str)
{
	string::const_iterator str_iter_beg = str.begin();
	while(*str_iter_beg == ' ')
		++str_iter_beg;

	string::const_iterator str_iter_end = str.end();
	while(*(--str_iter_end) == ' ');
	str_iter_end++;

	string trimmed_str {};
	trimmed_str.resize(str.size());
	std::copy(str_iter_beg, str_iter_end, trimmed_str.begin());

	return trimmed_str;
}

FileInfo get_file_info(const std::string &file_name)
{
	struct stat64 file_info_buf;
	stat64(file_name.c_str(), &file_info_buf);

	FileInfo file_info_ret;
	file_info_ret.file_size = file_info_buf.st_size;

	return file_info_ret;
}
